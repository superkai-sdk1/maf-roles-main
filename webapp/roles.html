<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>MAF ROLES</title>
	<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
	<link rel="stylesheet" href="../assets/font-akrobat/css.css">
	<link rel="stylesheet" href="../assets/roles-flex.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
	<link rel="stylesheet" href="https://cdn.materialdesignicons.com/7.2.96/css/materialdesignicons.min.css">
	<link rel="stylesheet" href="./styles-roles.css">
	<link rel="stylesheet" href="https://fonts.cdnfonts.com/css/gilroy-bold">
    <!-- Добавляем библиотеку qr-code-styling через CDN -->
    <script src="https://cdn.jsdelivr.net/npm/qr-code-styling@1.5.0/lib/qr-code-styling.js"></script>
	<style>
	/* Убрать фон у body и html */
	html, body {
	  background: transparent !important;
	}
	</style>
</head>
<body>
<div class="darker"></div>

<div id="app">
	<!-- Скрытое старое окно с номером комнаты -->
	<!-- <div v-if="showRoomPanel" class="room-number-panel">
		Комната {{ roomId }}
	</div> -->
	<!-- Новое окно с номером комнаты -->
	<div v-if="showRoomPanel" class="titan-room">
		<div style="width:100%;">
			<div>Комната {{ roomId }}</div>
			<!-- Контейнер для QR-кода -->
			<div ref="qrCanvas" style="margin:24px auto 0 auto; display:flex; justify-content:center;"></div>
			<div style="font-size:0.38em; color:#b9a6e5; margin-top:12px;">Отсканируйте QR-код для открытия панели управления</div>
		</div>
	</div>
	<!-- Левая: дополнительная информация -->
	<transition name="additional-info-panel" mode="out-in">
		<div v-if="panelState.additionalInfoVisible"
			 class="additional-info-panel"
			 :key="'left-info'">
			<span class="maf-anim-text" v-html="additionalInfoAnimated"></span>
		</div>
	</transition>
	<!-- Центр: основная информация -->
	<transition name="maf-info-panel" mode="out-in">
		<div v-if="panelState.mainInfoVisible && panelState.mainInfoText"
			 class="maf-info-panel main main-info-panel"
			 :key="'main'">
			<span class="maf-anim-text" v-html="mainInfoAnimated"></span>
		</div>
	</transition>
	<!-- Правая: статусы -->
	<transition name="maf-info-panel" mode="out-in">
		<div v-if="!panelState.hideLeaveOrder"
			 class="maf-info-panel statuses statuses-info-panel"
			 :key="'statuses'">
			<span class="maf-anim-list">
				<i class="fas fa-skull-crossbones status-icon status-die"></i>
				<span v-if="leaveOrder.killed.length">
					{{ dieTextLabel }}:
					<b>{{leaveOrder.killed.join(', ')}}</b>
				</span>
				<span v-else style="color:#888;">Нет убитых</span>
			</span>
			<span class="maf-anim-list" style="margin-left:12px;">
				<i class="mdi mdi-thumb-up-outline status-icon status-vote"></i>
				<span v-if="leaveOrder.voted.length">
					{{ voteTextLabel }}:
					<b>{{leaveOrder.voted.join(', ')}}</b>
				</span>
				<span v-else style="color:#888;">Нет заголосованных</span>
			</span>
		</div>
	</transition>
	<!-- ЛХ под статусами с отступом 5px -->
	<transition name="maf-info-panel" mode="out-in">
		<div v-if="bestMoveData && !panelState.hideBestMove"
			 class="maf-info-panel best-move best-move-info-panel"
			 :key="'best-move'">
			<span class="maf-anim-list">
				ПУ №{{ getPlayerNumber(bestMoveData.firstKilledPlayer) }}
				<span v-if="bestMoveData.bestMove && bestMoveData.bestMove.length">
					ЛХ {{ bestMoveData.bestMove.join(',') }}
				</span>
				<span v-else>
					Без лучшего хода
				</span>
			</span>
		</div>
	</transition>

	<!-- День/ночь (оставляем поверх, если нужно) -->
	<transition name="maf-info-panel" mode="out-in">
		<div v-if="panelState.activeInfoTab"
			 class="maf-info-panel day-night"
			 :class="{ 'day': panelState.activeInfoTab === 'day', 'night': panelState.activeInfoTab === 'night' }"
			 :key="panelState.activeInfoTab"
			 style="position: absolute; left: 50%; top: 0; transform: translate(-50%, -110%);">
			<span class="maf-anim-text" v-html="animText(panelState.activeInfoTab === 'day' ? 'День' : 'Ночь')"></span>
		</div>
	</transition>

	<!-- Основная зона игроков -->
	<transition name="maf-panel-fade" mode="out-in">
		<div v-if="peoples?.length && !panelState.hideSeating && !winnerTeam" class="people-row-bottom">
			<people-comp v-for="(people, index) in peoples"
						 :index="index + 1"
						 :value="people"
						 :hide-roles-status="panelState.hideRolesStatus"
						 :highlighted-player="highlightedPlayer"
						 :key="people.roleKey"></people-comp>
		</div>
	</transition>
	<!-- Модальное окно Темы -->
	<div v-if="showThemeModal" class="modal" @click.self="showThemeModal = false" style="z-index:99999;">
		<div class="modal-content" style="min-width:420px;max-width:98vw;position:relative;">
			<h2 style="margin-bottom:18px;font-size:1.3em;letter-spacing:.04em;">Темы и цвета</h2>
			<div style="margin-bottom:18px;">
				<b style="color:#b9a6e5;">Тема:</b>
				<div style="display:flex;gap:8px;margin-top:6px;">
					<div v-for="theme in themePresets"
						:key="theme.key"
						:title="theme.name"
						@click="selectTheme(theme.key)"
						:style="{
							border: selectedTheme === theme.key ? '3px solid #fff' : '2px solid var(--maf-accent-color)',
							borderRadius: '14px',
							cursor: 'pointer',
							width: '44px',
							height: '44px',
							boxShadow: selectedTheme === theme.key ? '0 0 10px 2px #fff8' : '0 0 6px 1px var(--maf-accent-color-44)',
							display: 'flex',
							alignItems: 'center',
							justifyContent: 'center',
							background: theme.bg,
							color: theme.onPrimary,
							fontSize: '1.3em'
						}">
						{{theme.icon}}
					</div>
				</div>
				<div style="margin-top:4px; color:#b9a6e5; font-size:0.98em;">
					{{ themePresets.find(t=>t.key===selectedTheme)?.name || '' }}
				</div>
			</div>
			<b style="color:#b9a6e5;">Цветовая схема:</b>
			<div style="display:flex; flex-wrap:wrap; gap:10px;">
				<div v-for="scheme in colorSchemes"
					 :key="scheme.key"
					 :title="scheme.name"
					 @click="selectColorScheme(scheme.key)"
					 :style="{
						border: selectedColorScheme === scheme.key ? '3px solid #fff' : '2px solid var(--maf-accent-color)',
						borderRadius: '14px',
						cursor: 'pointer',
						width: '54px',
						height: '54px',
						boxShadow: selectedColorScheme === scheme.key ? '0 0 14px 3px #fff8' : '0 0 8px 1px var(--maf-accent-color-44)',
						display: 'flex',
						alignItems: 'center',
						justifyContent: 'center',
						background: scheme.preview,
						position: 'relative'
					 }">
					<span style="font-size:0.9em; color:#fff; text-shadow:0 1px 4px #0008; font-weight:700;">
						{{scheme.icon || '★'}}
					</span>
					<span v-if="selectedColorScheme === scheme.key"
						  style="position:absolute;bottom:3px;right:6px;font-size:1.1em;color:#fff;">✔</span>
				</div>
			</div>
			<div style="margin-top:10px; color:#b9a6e5; font-size:0.98em;">
				{{ colorSchemes.find(s=>s.key===selectedColorScheme)?.name || '' }}
			</div>
			<button @click="showThemeModal = false" style="margin-top:22px;background:var(--maf-accent-color);color:#fff;border:none;border-radius:14px;padding:10px 32px;font-size:1.1em;cursor:pointer;">Закрыть</button>
		</div>
	</div>

	<!-- Победившая команда: модальное окно -->
	<transition name="winner-modal-fade">
		<div v-if="winnerTeam" class="winner-modal-overlay">
			<div class="winner-modal-content">
				<div class="winner-section">
					<div class="winner-title" v-if="winnerTeam === 'mafia'">Победа мафии</div>
					<div class="winner-title" v-if="winnerTeam === 'civilians'">Победили мирные</div>
					<div class="winner-cards-row">
						<winner-card
							v-for="p in winnerPlayers"
							:key="p.roleKey"
							:player="p"
						></winner-card>
					</div>
				</div>
				<div class="loser-section">
					<div class="loser-title" v-if="winnerTeam === 'mafia'">Проиграли</div>
					<div class="loser-title" v-if="winnerTeam === 'civilians'">Проиграли</div>
					<div class="loser-cards-row">
						<winner-card
							v-for="p in loserPlayers"
							:key="p.roleKey"
							:player="p"
						></winner-card>
					</div>
				</div>
			</div>
		</div>
	</transition>
</div>
<script>
Vue.component('role-badge', {
	 props: ['role', 'hide'],
	 computed: {
		 badgeLetter() {
			 switch (this.role) {
				 case 'don': return 'Д';
				 case 'sheriff': return 'Ш';
				 case 'black': return 'М';
				 default: return '';
			 }
		 },
		 badgeClass() {
			 switch (this.role) {
				 case 'don': return 'role-badge role-badge--don';
				 case 'sheriff': return 'role-badge role-badge--sheriff';
				 case 'black': return 'role-badge role-badge--mafia';
				 default: return '';
			 }
		 }
	 },
	 template: `<div v-if="badgeLetter && !hide" :class="badgeClass">{{ badgeLetter }}</div>`
 });

 Vue.component('status-badge', {
	 props: ['status', 'hide'],
	 computed: {
		 statusClass() {
			 switch (this.status) {
				 case 'killed': return 'status-badge status-badge--killed';
				 case 'voted': return 'status-badge status-badge--voted';
				 case 'removed': return 'status-badge status-badge--removed';
				 case 'tech_fall_removed': return 'status-badge status-badge--tech-fall-removed';
				 case 'fall_removed': return 'status-badge status-badge--fall-removed';
				 default: return 'status-badge';
			 }
		 },
		 iconHtml() {
			 switch (this.status) {
				 case 'killed': return '<i class="mdi mdi-crosshairs-gps"></i>';
				 case 'voted': return '<i class="mdi mdi-thumb-up-outline" style="color:var(--maf-accent-color)"></i>';
				 case 'removed': return '<i class="fas fa-ban" style="color:#e63946"></i>';
				 case 'tech_fall_removed': return '<i class="mdi mdi-flash" style="color:#ffd700"></i>';
				 case 'fall_removed': return '<i class="mdi mdi-alert-octagon" style="color:#ff9800"></i>';
				 default: return '';
			 }
		 },
		 show() {
			 return (
				['killed', 'voted', 'removed', 'tech_fall_removed', 'fall_removed'].includes(this.status)
				&& !this.hide
			 );
		 }
	 },
	 template: `<div v-if="show" :class="statusClass" v-html="iconHtml"></div>`
 });

 Vue.component('people-comp', {
	 props: ['value', 'index', 'hideRolesStatus', 'highlightedPlayer'],
	 data() {
		 return {
			 isHighlighted: false
		 }
	 },
	 computed: {
		 avatarStyle() {
			 // value.avatarCss может быть либо url(...), либо просто путь
			 if (!this.value.avatarCss) return {};
			 if (this.value.avatarCss.startsWith('url(')) {
				 return { backgroundImage: this.value.avatarCss };
			 }
			 return { backgroundImage: `url('${this.value.avatarCss}')` };
		 }
	 },
	 watch: {
		 highlightedPlayer: {
			 immediate: true,
			 handler(newVal) {
				 const shouldHighlight = newVal === this.value.roleKey;
				 if (shouldHighlight && !this.isHighlighted) {
					 this.isHighlighted = true;
				 } else if (!shouldHighlight && this.isHighlighted) {
					 this.$el.classList.add('highlight-fade-out');
					 setTimeout(() => {
						 this.isHighlighted = false;
						 this.$el.classList.remove('highlight-fade-out');
					 }, 500);
				 }
			 }
		 }
	 },
	 template: `
			<div class="people" :class="{
				'highlighted': isHighlighted,
				'killed': value.action === 'killed',
				'voted': value.action === 'voted',
				'removed': value.action === 'removed',
				'tech-fall-removed': value.action === 'tech_fall_removed',
				'fall-removed': value.action === 'fall_removed'
			}">
				<div class="avatar" :style="avatarStyle"></div>
				<div class="badges-wrapper">
					<role-badge :role="value.role" :hide="hideRolesStatus" />
					<status-badge :status="value.action" :hide="hideRolesStatus" />
				</div>
				<div class="people-name-box">
					<span class="people-name-index">{{ index }}</span>
					<div class="people-name-wrapper">
						<div class="people-name">
							{{value.login}}
						</div>
					</div>
				</div>
			</div>
		`
 });

 Vue.component('winner-card', {
	 props: ['player'],
	 computed: {
		 avatarStyle() {
			 if (!this.player.avatarCss) return {};
			 if (this.player.avatarCss.startsWith('url(')) {
				 return { backgroundImage: this.player.avatarCss };
			 }
			 return { backgroundImage: `url('${this.player.avatarCss}')` };
		 }
	 },
	 template: `
			<div class="winner-card">
				<div class="winner-avatar" :style="avatarStyle"></div>
				<div class="badges-wrapper">
					<role-badge :role="player.role" :hide="false" />
				</div>
				<div class="winner-name">{{ player.login }}</div>
			</div>
		`
 });

 const themePresets = [
		{ key: 'ultradark', name: 'Очень тёмная', bg: '#101014', surface: '#18181d', surfaceVariant: '#23232a', onPrimary: '#fff', onSurface: '#eaeaea', btn: '#23232a', icon: '🌑' },
		{ key: 'dark', name: 'Тёмная', bg: '#18181d', surface: '#23232a', surfaceVariant: '#2c2c36', onPrimary: '#fff', onSurface: '#f4eeff', btn: '#23232a', icon: '🌒' },
		{ key: 'neutral', name: 'Нейтральная', bg: '#23232a', surface: '#2c2c36', surfaceVariant: '#37374a', onPrimary: '#fff', onSurface: '#f4f4f4', btn: '#23232a', icon: '🌗' },
		{ key: 'light', name: 'Светлая', bg: '#f5f6fa', surface: '#e9eaf3', surfaceVariant: '#d8d9e6', onPrimary: '#222', onSurface: '#222', btn: '#fff', icon: '🌤️' },
		{ key: 'ultralight', name: 'Очень светлая', bg: '#ffffff', surface: '#f5f6fa', surfaceVariant: '#e9eaf3', onPrimary: '#111', onSurface: '#222', btn: '#fff', icon: '🌞' }
	];
	const colorSchemes = [
		{ key: 'purple', name: 'Фиолетовый', accent: '#ae8cff', preview: 'linear-gradient(135deg,#ae8cff 60%,#5b3e9c 100%)', icon:'💜' },
		{ key: 'blue', name: 'Голубой лед', accent: '#4fc3f7', preview: 'linear-gradient(135deg,#4fc3f7 60%,#1976d2 100%)', icon:'💧' },
		{ key: 'green', name: 'Изумруд', accent: '#6fe7b7', preview: 'linear-gradient(135deg,#6fe7b7 60%,#11998e 100%)', icon:'🌿' },
		{ key: 'red', name: 'Вишня', accent: '#e63946', preview: 'linear-gradient(135deg,#e63946 60%,#b12329 100%)', icon:'🍒' },
		{ key: 'orange', name: 'Мандарин', accent: '#ffb347', preview: 'linear-gradient(135deg,#ffb347 60%,#ff7f50 100%)', icon:'🍊' },
		{ key: 'pink', name: 'Розовый кварц', accent: '#ff6fcb', preview: 'linear-gradient(135deg,#ff6fcb 60%,#b24592 100%)', icon:'🌸' },
		{ key: 'yellow', name: 'Лимон', accent: '#ffe066', preview: 'linear-gradient(135deg,#ffe066 60%,#f9d423 100%)', icon:'🍋' },
		{ key: 'teal', name: 'Бирюза', accent: '#1de9b6', preview: 'linear-gradient(135deg,#1de9b6 60%,#1a2980 100%)', icon:'🦚' },
		{ key: 'gold', name: 'Золото', accent: '#ffd700', preview: 'linear-gradient(135deg,#ffd700 60%,#b8860b 100%)', icon:'🏆' },
		{ key: 'silver', name: 'Серебро', accent: '#b0c4de', preview: 'linear-gradient(135deg,#b0c4de 60%,#8e9eab 100%)', icon:'🥈' },
		{ key: 'aqua', name: 'Аквамарин', accent: '#00eaff', preview: 'linear-gradient(135deg,#00eaff 60%,#005bea 100%)', icon:'🌊' },
		{ key: 'lime', name: 'Лайм', accent: '#cddc39', preview: 'linear-gradient(135deg,#cddc39 60%,#8bc34a 100%)', icon:'🥝' },
		{ key: 'violet', name: 'Фиалка', accent: '#9f5afd', preview: 'linear-gradient(135deg,#9f5afd 60%,#6a3093 100%)', icon:'🔮' },
		{ key: 'brown', name: 'Кофе', accent: '#a0522d', preview: 'linear-gradient(135deg,#a0522d 60%,#6f4e37 100%)', icon:'☕' },
		{ key: 'black', name: 'Тёмная ночь', accent: '#222', preview: 'linear-gradient(135deg,#222 60%,#444 100%)', icon:'🌑' },
		{ key: 'mint', name: 'Мята', accent: '#98ff98', preview: 'linear-gradient(135deg,#98ff98 60%,#38ef7d 100%)', icon:'🌱' },
		{ key: 'peach', name: 'Персик', accent: '#ffb07c', preview: 'linear-gradient(135deg,#ffb07c 60%,#ff6e7f 100%)', icon:'🍑' },
		{ key: 'sky', name: 'Небо', accent: '#87ceeb', preview: 'linear-gradient(135deg,#87ceeb 60%,#4682b4 100%)', icon:'☁️' },
		{ key: 'rose', name: 'Роза', accent: '#ff007f', preview: 'linear-gradient(135deg,#ff007f 60%,#ffafcc 100%)', icon:'🌹' },
		{ key: 'olive', name: 'Олива', accent: '#808000', preview: 'linear-gradient(135deg,#808000 60%,#bfc000 100%)', icon:'🫒' },
		{ key: 'navy', name: 'Морской', accent: '#001f54', preview: 'linear-gradient(135deg,#001f54 60%,#034078 100%)', icon:'⚓' },
		{ key: 'coral', name: 'Коралл', accent: '#ff7f50', preview: 'linear-gradient(135deg,#ff7f50 60%,#ffb347 100%)', icon:'🪸' },
		{ key: 'sand', name: 'Песок', accent: '#ffe4b5', preview: 'linear-gradient(135deg,#ffe4b5 60%,#ffd700 100%)', icon:'🏖️' },
		{ key: 'plum', name: 'Слива', accent: '#8e4585', preview: 'linear-gradient(135deg,#8e4585 60%,#d291bc 100%)', icon:'🍇' },
		{ key: 'ice', name: 'Лёд', accent: '#b2f7ef', preview: 'linear-gradient(135deg,#b2f7ef 60%,#40c9ff 100%)', icon:'🧊' },
		{ key: 'fire', name: 'Огонь', accent: '#ff512f', preview: 'linear-gradient(135deg,#ff512f 60%,#dd2476 100%)', icon:'🔥' },
		{ key: 'forest', name: 'Лес', accent: '#228b22', preview: 'linear-gradient(135deg,#228b22 60%,#a8e063 100%)', icon:'🌲' },
		{ key: 'steel', name: 'Сталь', accent: '#4682b4', preview: 'linear-gradient(135deg,#4682b4 60%,#b0c4de 100%)', icon:'🔩' },
		{ key: 'ruby', name: 'Рубин', accent: '#e0115f', preview: 'linear-gradient(135deg,#e0115f 60%,#ff6fcb 100%)', icon:'💎' },
		{ key: 'amber', name: 'Янтарь', accent: '#ffbf00', preview: 'linear-gradient(135deg,#ffbf00 60%,#ff8008 100%)', icon:'🟡' }
	];
	const app = new Vue({
		el: '#app',
		data: {
			peoples: undefined,
			panelState: {
				mainInfoText: "",
				additionalInfoText: "",
				mainInfoVisible: true,
				additionalInfoVisible: true,
				hideSeating: false,
				hideLeaveOrder: false,
				hideRolesStatus: false,
				hideBestMove: false,
				activeInfoTab: null,
				showRoomNumber: false
			},
			mainInfoAnimated: "",
			additionalInfoAnimated: "",
			prevMainInfo: "",
			prevAdditionalInfo: "",
			leaveOrderAnimated: {die: [], vote: []},
			leaveOrderPrev: {die: [], vote: []},
			leaveOrderAnimKey: 0,			highlightedPlayer: null,
			bestMoveData: null,
			roomId: null,			ws: null,
			receivedPanelState: false,
			qrCodeStyling: null, // для хранения экземпляра QR-кода
			killedOrder: [],   // порядок выставления статуса 'killed'
			votedOrder: [],  // порядок выставления статуса 'voted'
			colorScheme: 'purple',
			themePresets,
			selectedTheme: 'ultradark',
			colorSchemes,
			selectedColorScheme: 'purple',
			showThemeModal: false,
			showSettingsModal: false,
			winnerTeam: null,
		},
		computed: {
			leaveOrder() {
				const killed = this.killedOrder
					.map(roleKey => {
						const idx = this.peoples?.findIndex(p => p.roleKey === roleKey);
						return idx !== -1 ? idx + 1 : null;
					})
					.filter(n => n !== null);

				const voted = this.votedOrder
					.map(roleKey => {
						const idx = this.peoples?.findIndex(p => p.roleKey === roleKey);
						return idx !== -1 ? idx + 1 : null;
					})
					.filter(n => n !== null);

				const removed = this.peoples?.filter(p => p.action === 'removed').map((p, i) => i + 1) || [];
				const techFallRemoved = this.peoples?.filter(p => p.action === 'tech_fall_removed').map((p, i) => i + 1) || [];
				const fallRemoved = this.peoples?.filter(p => p.action === 'fall_removed').map((p, i) => i + 1) || [];

				return { killed, voted, removed, techFallRemoved, fallRemoved };
			},
			dieTextLabel() {
				const n = this.leaveOrder.killed.length;
				if (n === 1) return "Убит";
				if (n > 1) return "Убиты";
				return "Убит";
			},
			voteTextLabel() {
				const n = this.leaveOrder.voted.length;
				if (n === 1) return "Заголосован";
				if (n > 1) return "Заголосованы";
				return "Заголосован";
			},
			showRoomPanel() {
				const hasPlayers = Array.isArray(this.peoples) && this.peoples.length > 0;
				console.log('[showRoomPanel]', 'roomId:', this.roomId, 'hasPlayers:', hasPlayers, 'panelState:', this.panelState);
				if (!this.roomId) return true;
				if (!hasPlayers) return true;
				if (this.panelState && this.panelState.showRoomNumber && this.roomId) return true;
				return false;
			},
			additionalInfoFull() {
				// Формируем строку по шаблону из panelState.gameSelected, panelState.tableSelected, panelState.games
				const ps = this.panelState;
				const games = ps.games || [];
				const gameCount = games.length || 1;
				const currentGame = ps.gameSelected || 1;
				let gameObj = null;
				if (games.length) {
					gameObj = games.find(g => Number(g.gameNum) === Number(currentGame));
				}
				const tables = gameObj && Array.isArray(gameObj.game) ? gameObj.game : [];
				const tableCount = tables.length || 1;
				const currentTable = ps.tableSelected || 1;
				let result = "";
				if (tableCount > 1) {
					result += `Номер стола: ${currentTable} | `;
				}
				result += `Игра ${currentGame} из ${gameCount}`;
				return result;
			},
			winnerPlayers() {
				if (!this.winnerTeam || !Array.isArray(this.peoples)) return [];
				if (this.winnerTeam === 'mafia') {
					// Дон и мафии (роль don или black)
					return this.peoples.filter(p => p.role === 'don' || p.role === 'black');
				} else if (this.winnerTeam === 'civilians') {
					// Мирные (без роли) и шериф
					return this.peoples.filter(p => !p.role || p.role === 'sheriff');
				}
				return [];
			},
			loserPlayers() {
				if (!this.winnerTeam || !Array.isArray(this.peoples)) return [];
				if (this.winnerTeam === 'mafia') {
					// Мирные (без роли) и шериф
					return this.peoples.filter(p => !p.role || p.role === 'sheriff');
				} else if (this.winnerTeam === 'civilians') {
					// Дон и мафии (роль don или black)
					return this.peoples.filter(p => p.role === 'don' || p.role === 'black');
				}
				return [];
			},
		},
		watch: {
			'panelState.mainInfoText': {
				immediate: true,
				handler(val) {
					if (val !== this.prevMainInfo) {
						this.mainInfoAnimated = this.animText(val);
						this.prevMainInfo = val;
					}
				}
			},
			'panelState.additionalInfoText': {
				immediate: true,
				handler(val) {
					// Теперь используем additionalInfoFull для анимации
					this.additionalInfoAnimated = this.animText(this.additionalInfoFull);
					this.prevAdditionalInfo = val;
				}
			},
			// Следим за изменениями gameNumber и tableNumber
			'panelState.gameNumber': {
				immediate: true,
				handler() {
					this.additionalInfoAnimated = this.animText(this.additionalInfoFull);
				}
			},
			'panelState.tableNumber': {
				immediate: true,
				handler() {
					this.additionalInfoAnimated = this.animText(this.additionalInfoFull);
				}
			},
			'panelState.gameSelected': {
				immediate: true,
				handler() {
					this.additionalInfoAnimated = this.animText(this.additionalInfoFull);
				}
			},
			'panelState.tableSelected': {
				immediate: true,
				handler() {
					this.additionalInfoAnimated = this.animText(this.additionalInfoFull);
				}
			},
			'panelState.games': {
				immediate: true,
				handler() {
					this.additionalInfoAnimated = this.animText(this.additionalInfoFull);
				}
			},
			leaveOrder: {
				handler(newVal) {
					if (
						JSON.stringify(newVal.killed) !== JSON.stringify(this.leaveOrderPrev.killed) ||
						JSON.stringify(newVal.voted) !== JSON.stringify(this.leaveOrderPrev.voted)
					) {
						this.leaveOrderAnimated = {
							killed: [...newVal.killed],
							voted: [...newVal.voted]
						};
						this.leaveOrderPrev = {
							killed: [...newVal.killed],
							voted: [...newVal.voted]
						};
						this.leaveOrderAnimKey++;
					}
				},
				deep: true,
				immediate: true
			},
			roomId(newVal) {
				this.$nextTick(() => {
					this.renderQrCode();
				});
			},
			'panelState.colorScheme': {
				immediate: true,
				handler(val) {
					if (val && colorSchemes.some(s=>s.key===val)) {
						this.colorScheme = val;
						this.applyColorScheme(val);					}
				}
			},
			showRoomPanel() {
				this.$nextTick(() => {
					this.renderQrCode();
				});
			},
		},
		methods: {
			animText(txt) {
				if (!txt) return "";
				return txt.split("").map((l, i) => `<span class="maf-anim-text" style="animation-delay:${i*0.018}s">${l === " " ? " " : l}</span>`).join("");
			},
			getPlayerNumber(roleKey) {
				const player = this.peoples.find(p => p.roleKey === roleKey);
				const index = this.peoples.indexOf(player);
				return index !== -1 ? index + 1 : '';
			},
			connectWS(roomId) {
				if (this.ws) {
					this.ws.close();
				}
				this.ws = new WebSocket('wss://minahor.ru/bridge');
				this.ws.onopen = () => {
					this.ws.send(JSON.stringify({ joinRoom: roomId }));
				};
				this.ws.onmessage = ev => {
					let data;
					try { data = JSON.parse(ev.data); } catch { return; }
					if (data.type === "state") {
						this.applyFullState(data);
						this.receivedPanelState = true;
						this.saveRoomStateToServer();
					}
					if (data.type === "winnerTeam") {
						this.winnerTeam = data.winnerTeam;
						this.saveRoomStateToServer();
					}
					if (data.type === "roleChange") {
						this.applyRoleChange(data);
						this.saveRoomStateToServer();
					}
					if (data.type === "actionChange") {
						this.applyActionChange(data);
						this.saveRoomStateToServer();
					}
					if (data.type === "foulChange") {
						this.applyFoulChange(data);
						this.saveRoomStateToServer();
					}
					if (data.type === "techFoulChange") {
						this.applyTechFoulChange(data);
						this.saveRoomStateToServer();
					}
					if (data.type === "removeChange") {
						this.applyRemoveChange(data);
						this.saveRoomStateToServer();
					}
					if (data.type === "highlight") {
						this.highlightedPlayer = data.roleKey;
						this.saveRoomStateToServer();
					}
					if (data.type === "panelStateChange") {
						if (data.panelState) {
							this.panelState = Object.assign({}, this.panelState, data.panelState);
							this.saveRoomStateToServer();
						}
					}
					if (data.type === "bestMoveChange" || data.type === "bestMoveConfirm") {
						this.bestMoveData = {
							bestMove: data.bestMove,
							firstKilledPlayer: data.firstKilledPlayer
						};
						this.saveRoomStateToServer();
					}
					// ...добавьте другие типы по необходимости...
				};
			},
			sendFullState() {
				// roles.html не отправляет state!
			},
			applyPartialUpdate(data) {
				// roles.html не применяет частичные изменения!
			},			applyFullState(data) {
				if (data.panelState !== undefined) {
					this.panelState = Object.assign({}, this.panelState, data.panelState);
					this.receivedPanelState = true;
					if (data.panelState.tableOut !== undefined) {
						// ИСПРАВЛЕНО: Не перезаписываем целиком, а синхронизируем статусы
						this.syncPeoples(data.panelState.tableOut);
					} else if (data.panelState.peoples !== undefined) {
						this.syncPeoples(data.panelState.peoples);
					}
				}
				if (data.tableOut !== undefined) {
					// ИСПРАВЛЕНО: Не перезаписываем целиком, а синхронизируем статусы
					this.syncPeoples(data.tableOut);
				}
				if (data.highlightedPlayer !== undefined) this.highlightedPlayer = data.highlightedPlayer;
				if (data.bestMoveData !== undefined) this.bestMoveData = data.bestMoveData;
				if (data.winnerTeam !== undefined) this.winnerTeam = data.winnerTeam;

				// --- корректно обновляем порядок dieOrder/voteOrder ---
				if (this.peoples && Array.isArray(this.peoples)) {
					const currentKilled = this.peoples.filter(p => p.action === 'killed').map(p => p.roleKey);
					const currentVoted = this.peoples.filter(p => p.action === 'voted').map(p => p.roleKey);

					// Добавляем новые в конец, удаляем отсутствующие
					this.killedOrder = this.killedOrder.filter(k => currentKilled.includes(k));
					currentKilled.forEach(k => {
						if (!this.killedOrder.includes(k)) this.killedOrder.push(k);
					});

					this.votedOrder = this.votedOrder.filter(k => currentVoted.includes(k));
					currentVoted.forEach(k => {
						if (!this.votedOrder.includes(k)) this.votedOrder.push(k);
					});
				}
			},
			updateLeaveOrders() {
				if (this.peoples && Array.isArray(this.peoples)) {
					const currentKilled = this.peoples.filter(p => p.action === 'killed').map(p => p.roleKey);
					const currentVoted = this.peoples.filter(p => p.action === 'voted').map(p => p.roleKey);
					this.killedOrder = this.killedOrder.filter(k => currentKilled.includes(k));
					currentKilled.forEach(k => {
						if (!this.killedOrder.includes(k)) this.killedOrder.push(k);
					});
					this.votedOrder = this.votedOrder.filter(k => currentVoted.includes(k));
					currentVoted.forEach(k => {
						if (!this.votedOrder.includes(k)) this.votedOrder.push(k);
					});
				}
			},
			applyRoleChange(data) {
				if (!this.peoples) return;
				const idx = this.peoples.findIndex(p => p.roleKey === data.roleKey);
				if (idx !== -1) {
					this.$set(this.peoples[idx], 'role', data.role || null);
					this.updateLeaveOrders();
				}
			},
			applyActionChange(data) {
				if (!this.peoples) return;
				const idx = this.peoples.findIndex(p => p.roleKey === data.roleKey);
				if (idx !== -1) {
					this.$set(this.peoples[idx], 'action', data.action || null);
					this.updateLeaveOrders();
				}
			},
			applyFoulChange(data) {
				if (!this.peoples) return;
				const idx = this.peoples.findIndex(p => p.roleKey === data.roleKey);
				if (idx !== -1) {
					this.$set(this.peoples[idx], 'foul', data.value);
					this.updateLeaveOrders();
				}
			},
			applyTechFoulChange(data) {
				if (!this.peoples) return;
				const idx = this.peoples.findIndex(p => p.roleKey === data.roleKey);
				if (idx !== -1) {
					this.$set(this.peoples[idx], 'techFoul', data.value);
					this.updateLeaveOrders();
				}
			},
			applyRemoveChange(data) {
				if (!this.peoples) return;
				const idx = this.peoples.findIndex(p => p.roleKey === data.roleKey);
				if (idx !== -1) {
					this.$set(this.peoples[idx], 'removed', data.value);
					this.updateLeaveOrders();
				}
			},
			saveRoomStateToServer() {
				// Сохраняем peoples и panelState инкрементально
				if (!this.roomId) return;
				fetch('/api/room-state.php?roomId=' + encodeURIComponent(this.roomId), {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						peoples: this.peoples,
						panelState: this.panelState,
						winnerTeam: this.winnerTeam,
						bestMoveData: this.bestMoveData
					})
				});
			},
			async loadRoomStateFromServer() {
				if (!this.roomId) return;
				try {
					const resp = await fetch('/api/room-state.php?roomId=' + encodeURIComponent(this.roomId));
					if (resp.ok) {
						const state = await resp.json();
						if (state.peoples) this.peoples = state.peoples;
						if (state.panelState) this.panelState = state.panelState;
						if (state.winnerTeam !== undefined) this.winnerTeam = state.winnerTeam;
						if (state.bestMoveData !== undefined) this.bestMoveData = state.bestMoveData;
					}				} catch (e) { /* ignore */ }
			},
			renderQrCode() {
				// Рендер QR-кода только если окно с номером комнаты показано
				if (!this.showRoomPanel || !this.roomId) return;
				let url = window.location.origin + window.location.pathname.replace(/roles\.html$/, "panel.html") + '?roomId=' + encodeURIComponent(this.roomId);
				if (this.qrCodeStyling) {
					this.qrCodeStyling.update({ data: url });
				} else if (window.QRCodeStyling) {
					this.qrCodeStyling = new window.QRCodeStyling({
						width: 180,
						height: 180,
						data: url,
						image: "",
						dotsOptions: {
							color: "#ae8cff",
							type: "rounded"
						},
						backgroundOptions: {
							color: "rgba(0,0,0,0)"
						},
						cornersSquareOptions: {
							color: "#ae8cff",
							type: "extra-rounded"
						},
						cornersDotOptions: {
							color: "#ae8cff",
							type: "dot"
						}
					});
				}
				const qrDiv = this.$refs.qrCanvas;
				if (qrDiv && this.qrCodeStyling) {
					qrDiv.innerHTML = "";
					this.qrCodeStyling.append(qrDiv);
				}
			},
			applyColorScheme(schemeKey) {
				const scheme = colorSchemes.find(s=>s.key===schemeKey) || colorSchemes[0];
				document.documentElement.style.setProperty('--maf-accent-color', scheme.accent);
				let rgb = scheme.accent;
				if (rgb.startsWith('#')) {
					let hex = rgb.replace('#','');
					if (hex.length === 3) hex = hex.split('').map(x=>x+x).join('');
					const r = parseInt(hex.substring(0,2),16);
					const g = parseInt(hex.substring(2,4),16);
					const b = parseInt(hex.substring(4,6),16);
					rgb = `${r},${g},${b}`;
					const brightness = (r*299 + g*587 + b*114) / 1000;
					if (brightness > 180) {
						document.body.setAttribute('data-accent-light', 'true');
						document.documentElement.style.setProperty('--maf-role-badge-text', '#222');
					} else {
						document.body.removeAttribute('data-accent-light');
						document.documentElement.style.setProperty('--maf-role-badge-text', '#fff');
					}
				}
				document.documentElement.style.setProperty('--maf-accent-color-rgb', rgb);
				document.documentElement.style.setProperty('--maf-panel-glow', `0 0 18px 4px rgba(${rgb},0.27), 0 0 1px 0px #31225c, 0 2px 8px #0003`);
			},
			applyTheme(theme) {
				if (!theme) return;
				document.documentElement.style.setProperty('--maf-bg-main', theme.bg);
				document.documentElement.style.setProperty('--maf-bg-secondary', theme.surface);
				document.documentElement.style.setProperty('--maf-bg-accent', theme.surfaceVariant);
				document.documentElement.style.setProperty('--maf-text-main', theme.onPrimary);
				document.documentElement.style.setProperty('--maf-btn-main', theme.btn || (theme.key === 'light' || theme.key === 'ultralight' ? '#fff' : '#23232a'));
				document.documentElement.style.setProperty('--md3-bg', theme.bg);
				document.documentElement.style.setProperty('--md3-surface', theme.surface);
				document.documentElement.style.setProperty('--md3-surface-variant', theme.surfaceVariant);
				document.documentElement.style.setProperty('--md3-on-primary', theme.onPrimary);
				document.documentElement.style.setProperty('--md3-on-surface', theme.onSurface);
			},
			selectTheme(themeKey) {
				this.selectedTheme = themeKey;
				const theme = this.themePresets.find(t=>t.key===themeKey);
				this.applyTheme(theme);
				this.syncTheme();
			},
			selectColorScheme(schemeKey) {
				this.selectedColorScheme = schemeKey;
				this.applyColorScheme(schemeKey);
				this.syncTheme();
			},
			syncTheme() {
				// Отправить тему и цветовую схему в panel.html
				window.parent.postMessage({
					source: "obs-mafia-theme-sync",
					theme: this.themePresets.find(t=>t.key===this.selectedTheme),
					colorScheme: this.selectedColorScheme
				}, "*");
			},
			syncPeoples(newPeoples) {
				if (!newPeoples || !Array.isArray(newPeoples)) return;
				
				// Если у нас ещё нет массива peoples, просто устанавливаем новый
				if (!this.peoples || !Array.isArray(this.peoples)) {
					this.peoples = [...newPeoples];
					return;
				}
				
				// Синхронизируем существующий массив
				newPeoples.forEach((newPlayer, index) => {
					if (!this.peoples[index]) {
						// Добавляем нового игрока
						this.$set(this.peoples, index, {...newPlayer});
					} else {
						// Обновляем существующего игрока, сохраняя критические статусы 'killed' и 'voted'
						const existingPlayer = this.peoples[index];
						const existingAction = existingPlayer.action;
						
						// Сохраняем все поля, но с осторожностью для action
						Object.keys(newPlayer).forEach(key => {
							if (key === 'action') {
								// ЗАЩИТА: Если у нас есть критический статус 'killed' или 'voted', 
								// не перезаписываем его значением из newPlayer, если оно null
								if (['killed', 'voted'].includes(existingAction) && !newPlayer[key]) {
									// Оставляем существующий критический статус
									return;
								}
							}
							this.$set(this.peoples[index], key, newPlayer[key]);
						});
					}
				});
				
				// Удаляем лишних игроков, если новый массив короче
				if (this.peoples.length > newPeoples.length) {
					this.peoples.splice(newPeoples.length);
				}
			},
		},
		mounted() {
			// Получаем roomId из URL или DOM, если есть
			let roomId = null;
			const urlParams = new URLSearchParams(window.location.search);
			if (urlParams.has('room')) {
				roomId = urlParams.get('room');
			}
			if (!roomId) {
				const el = document.getElementById('room-id');
				if (el) roomId = el.textContent.trim();
			}
			if (!roomId) {
				roomId = Math.floor(1000 + Math.random() * 9000).toString();
			}
			this.roomId = roomId;
			this.connectWS(roomId);

			// Для синхронизации: слушаем сообщения от panel.html через window.postMessage
			window.addEventListener("message", (event) => {
				if (event.data && event.data.source === "obs-mafia-panel-sync" && event.data.roomId === this.roomId) {
					const data = event.data.payload;
					if (data.panelState !== undefined) {
						this.panelState = Object.assign({}, this.panelState, data.panelState);
						this.receivedPanelState = true; // Флаг: получили состояние от panel.html
					}
					if (data.tableOut !== undefined) this.peoples = data.tableOut;
					if (data.highlightedPlayer !== undefined) this.highlightedPlayer = data.highlightedPlayer;
					if (data.bestMoveData !== undefined) this.bestMoveData = data.bestMoveData;
				}
				// Обработка синхронизации темы
				if (event.data && event.data.source === "obs-mafia-theme-sync" && event.data.theme) {
					this.applyTheme(event.data.theme);
					if (event.data.colorScheme) {
						this.selectedColorScheme = event.data.colorScheme;
						this.applyColorScheme(event.data.colorScheme);
					}
				}
			});
			this.$nextTick(() => {
				this.renderQrCode();
				// Применяем схему при старте
				if (this.panelState.colorScheme) {
					this.applyColorScheme(this.panelState.colorScheme);
				}
				// Применяем дефолтную тему при старте
				this.applyTheme({
					bg: '#18122b',
					surface: '#212136',
					surfaceVariant: '#241c3b',
					onPrimary: '#fff',
					onSurface: '#f4eeff'
				});
			});
			// Удаляем загрузку цветовой схемы из localStorage
			this.colorScheme = 'purple';
			this.applyColorScheme(this.colorScheme);
			this.loadRoomStateFromServer();
		},
	});
	// --- Синхронизация с panel.html через WebSocket ---
	// Если panel.html отправляет изменения через ws, этот roles.html их получит и применит (см. ws.onmessage выше)
	// Если нужно, чтобы roles.html мог отправлять изменения обратно, реализуйте соответствующие методы и отправку через ws.send

</script>
</body>
</html>